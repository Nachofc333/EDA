# -*- coding: utf-8 -*-
"""BST-NonLeaves-sol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14yx2olA6jhyMeeNeaIM3EdOSWvD0ZieS

# PROBLEMA 1 - Árboles Binarios de Búsqueda / Problem 1 - Binary Search Trees

## Instrucciones / Instructions:

- Puntuación: 2 puntos.
- Duración: 30 minutos para desarrollar y subir tu solución a la actividad Problema 1. 
- Lee antentamente el problema. Vuelve a leer el problema una segunda vez. 
- Después de haber leído el enunciado dos veces, si tienes alguna duda pregunta en chat de la sesión.
- Descarga el fichero problema1.py y completa tu solución. 
- En ningún caso puedes modificar, la función Test de unittest.
- Cuando queden 5 minutos el profesor, te avisará para que vayas subiendo tu solución. Las soluciones enviadas más tarde de los 35 minutos no serán evaluadas. 


En un árbol binario, nn nodo no hoja es un nodo que al menos tiene un hijo. Por ejemplo, en el siguiente árbol:

<img src='https://www.gatevidyalay.com/wp-content/uploads/2018/07/Binary-Search-Tree-Example.png' width='50%'>

la lista de nodos no hojas en orden descendiente es: lista=[40,36,30,25,20,10]

Sea MyBST la clase que implementa un árbol binario de búsqueda  (en realidad es una versión simplificada que sólo incluye los métodos necesarios para crear y poblar un árbol). Implementa método, **getNonLeaves()**, que devuelve una lista de Python que contiene los elementos de los nodos que no son hojas. 
La lista debe estar ordenada de forma descendiente (de mayor a menor). 

-No puedes aplicar ningún método de ordenación (método de burbuja o inserción ordenada) para ordenar la lista. 
- Tampoco puedes usar los métodos sort() o sorted() que proporciona Python. 
- Tampoco puedes usar listas auxiliares (de ningún tipo) para desarrollar tu solución
"""

class Node: 
    def __init__(self,elem,left=None,right=None,parent=None):
        self.elem=elem
        self.left=left
        self.right=right
        self.parent=parent
    
class MyBST:
    def __init__(self):
        self.root=None
        
    def insert(self,x):
        """inserts a new node, with element x, into the tree"""
        if self.root==None:
            self.root=Node(x)
        else:
            self._insertNode(self.root,x)


    def _insertNode(self,node,x):
        """método recursivo"""
        if node.elem==x:
            #print('Error: la clave ya existe. No permitimos duplicados')
            return 

        if x<node.elem:

            if node.left==None:
                #ya he encontrado su sitio
                newNode=Node(x)
                newNode.parent=node
                node.left=newNode
            else:
                self._insertNode(node.left,x)

        else: #x>node.elem

            if node.right==None:
                #ya he encontrado la posición
                newNode=Node(x)
                newNode.parent=node
                node.right=newNode
            else:
                 self._insertNode(node.right,x)
        

    def draw(self):
      """Function to draw the tree"""
      self._draw('',self.root,False)
      print()
      
    def _draw(self,prefix, node, isLeft):
        if node !=None:
            self._draw(prefix + "     ", node.right, False)
            print(prefix + ("|-- ") + str(node.elem))
            self._draw(prefix + "     ", node.left, True)


    def getNonLeaves(self):
        """returns a list with the keys of the nodes that are not leaves"""
        result=[]
        self._getNonLeaves(self.root,result)
        return result

    def _getNonLeaves(self,node,lst_nonleaves):
        if node!=None:
            self._getNonLeaves(node.right,lst_nonleaves)
            if node.left!=None or node.right!=None:
                lst_nonleaves.append(node.elem)
            self._getNonLeaves(node.left,lst_nonleaves)

values=[25,20,36,10,22,30,40,5,12,28,38,48]
tree=MyBST()
for x in values:
    tree.insert(x)
tree.draw()
print('getNonLeaves()',tree.getNonLeaves())

import unittest


class Test(unittest.TestCase):

    #variable estática para almacenar la nota
    nota=0

    def setUp(self):
        values=[25,20,36,10,22,30,40,5,12,28,38,48]
        self.bst1=MyBST()
        for x in values:
            self.bst1.insert(x)
        
        #self.bst1.draw()
    
        
        values=[12, 16, 19, 20, 4, 14, 2, 18, 10, 8, 24, 6, 1, 13]
        self.bst2=MyBST()
        for x in values:
            self.bst2.insert(x)

        #self.bst2.draw()

    def test_printNota(self):
        print('\n\n*************************')
        print("\nNota Final:",Test.nota)  
        print('*************************')

    def test1_getNonLeaves(self):
        print('Case 1: tree is empty')
        tree=MyBST()
        self.assertEqual(len(tree.getNonLeaves()), 0, "Fail: list should be empty")
        print('\t\t nota += 1')
        Test.nota+=1

    def test2_getNonLeaves(self):
        print('Case 2: tree only has one node')
        tree=MyBST()
        tree.insert(10)
        self.assertEqual(len(tree.getNonLeaves()), 0, "Fail: list should be empty")
        print('\t\t nota += 2')
        Test.nota+=2
        
    def test3_getNonLeaves(self):
        print('Case 3: tree only has two nodes')
        tree=MyBST()
        tree.insert(10)
        tree.insert(15)
        result=tree.getNonLeaves()
        print('result:  ',result)
        expected=[10]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [10]")
        print('\t\t nota += 1')
        Test.nota+=1

    def test4_getNonLeaves(self):
        print('Case 4: tree only has three nodes and no left subtree')
        tree=MyBST()
        tree.insert(10)
        tree.insert(15)
        tree.insert(20)
        result=tree.getNonLeaves()
        print('result:  ',result)
        expected=[15,10]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [15,10]")
        print('\t\t nota += 2')
        Test.nota+=2

    def test5_getNonLeaves(self):
        print('Case 5: tree only has three nodes and no right subtree')
        tree=MyBST()
        tree.insert(20)
        tree.insert(15)
        tree.insert(10)
        result=tree.getNonLeaves()
        print('result:  ',result)
        expected=[20,15]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [20,15]")
        print('\t\t nota += 2')
        Test.nota+=2
    
    def test6_getNonLeaves(self):
        print('Case 6: tree is balanced and only has three nodes')
        tree=MyBST()
        tree.insert(15)
        tree.insert(10)
        tree.insert(20)
        result=tree.getNonLeaves()
        print('result:  ',result)
        expected=[15]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [10]")
        print('\t\t nota += 2')
        Test.nota+=2

    def test7_getNonLeaves(self):
        print('Case 7: tree only has two nodes')
        result=self.bst1.getNonLeaves()
        print('result:  ',result)
        expected=[40, 36, 30, 25, 20, 10]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [40, 36, 30, 25, 20, 10]")
        print('\t\t nota += 5')
        Test.nota+=5

    def test8_getNonLeaves(self):
        print('Case 7: tree only has two nodes')
        result=self.bst2.getNonLeaves()
        print('result:  ',result)
        expected=[20, 19, 16, 14, 12, 10, 8, 4, 2]
        print('expected:  ',expected)
        self.assertListEqual(result, expected, "Fail: list should be [20, 19, 16, 14, 12, 10, 8, 4, 2]")
        print('\t\t nota += 5')
        Test.nota+=5    

        
#Comentar para usarlo en spyder
unittest.main(argv=['first-arg-is-ignored'], exit=False)

#Descomenar para usarlo en Spyder
#if __name__ == '__main__':
#    unittest.main()